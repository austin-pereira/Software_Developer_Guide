# The Software Development Lifecycle & Essential Practices

Six Components of Building Software:

Requirement Gathering: Understanding and documenting the user's needs and expectations for the software.
Design: Creating a blueprint of the software's structure, functionality, and user interface.
Implementation: Writing the actual code that brings the design to life.
Testing: Identifying and fixing errors or defects in the software to ensure it works as intended.
Deployment: Making the software available to users.
Maintenance: Updating, fixing bugs, and adding new features to keep the software relevant and functional over time.
Goals of Good Software Design:

Satisfy user requirements: The software should meet the needs and expectations of its intended users.
Low maintenance and production cost: The software should be easy to maintain and update, and it should not be expensive to produce.
Timely delivery: The software should be delivered on time and within budget.
Ease of use and reusability: The software should be user-friendly and its components should be reusable in other projects.
High performance: The software should be efficient and responsive.
Umbrella Activities:

These activities support the entire software development process:

Project Tracking and Control: Monitoring progress, identifying risks, and taking corrective action.
Risk Management: Identifying, assessing, and mitigating potential risks to the project.
Software Quality Assurance: Ensuring the software meets quality standards.
Technical Reviews: Evaluating the software's design and implementation.
Measurement: Collecting data to assess the software's performance and effectiveness.
Software Configuration Management: Managing changes to the software.
Reusability Management: Identifying and reusing components in other projects.
Software Development Methodologies:

Waterfall: Linear, sequential phases.
Incremental: Series of mini-Waterfall cycles, each delivering a working increment.
Rapid Application Development (RAD): Emphasizes rapid prototyping and iterative development.
Spiral: Risk-driven approach, with each cycle focusing on identifying and mitigating risks.
Agile: Incremental and iterative development, valuing individuals and interactions, working software, customer collaboration, and responding to change.
Agile vs. Waterfall: Which One to Pick?

Choose Agile for projects with evolving requirements, where flexibility and rapid delivery are key.
Choose Waterfall for projects with stable requirements and a well-defined scope, where predictability is crucial.
Requirement Engineering Activities:

Inception: Understanding the problem and the needs of stakeholders.
Elicitation: Gathering requirements from stakeholders through interviews, surveys, etc.
Analysis and Negotiation: Analyzing the requirements for feasibility and resolving conflicts.
System Modeling: Creating models to visualize the system's behavior and structure.
Requirements Specification: Documenting the requirements in a clear and concise format.
Requirements Validation: Ensuring the requirements are accurate, complete, and consistent.
Requirements Management: Tracking and managing changes to the requirements throughout the project lifecycle.
Line of Code (LOC):

A metric to measure the size of a software program.

Counts lines of executable code, including blank lines and comments.

Does not count blank lines without code or comments.

Advantages: Simple to calculate, provides a rough estimate of the program's size.

Disadvantages:  Not an accurate measure of complexity or effort, can be misleading if code is poorly formatted.
